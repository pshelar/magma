From 2fbb9d8b131cf18aa71d5526407ec4a2dd5b1be5 Mon Sep 17 00:00:00 2001
From: Pravin B Shelar <pbshelar@fb.com>
Date: Sat, 5 Dec 2020 13:58:10 -0800
Subject: [PATCH 8/9] ii

iii
---
 datapath/flow_netlink.c                        | 1 +
 datapath/linux/compat/include/net/ip_tunnels.h | 7 ++++---
 lib/dpif-netlink-rtnl.c                        | 4 +++-
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/datapath/flow_netlink.c b/datapath/flow_netlink.c
index b51b99c82..a1842e1c3 100644
--- a/datapath/flow_netlink.c
+++ b/datapath/flow_netlink.c
@@ -45,6 +45,7 @@
 #include <net/geneve.h>
 #include <net/ip.h>
 #include <net/ipv6.h>
+#include <net/ip_tunnels.h>
 #include <net/ndisc.h>
 #include <net/mpls.h>
 #include <net/vxlan.h>
diff --git a/datapath/linux/compat/include/net/ip_tunnels.h b/datapath/linux/compat/include/net/ip_tunnels.h
index a0dcc2667..23272b55e 100644
--- a/datapath/linux/compat/include/net/ip_tunnels.h
+++ b/datapath/linux/compat/include/net/ip_tunnels.h
@@ -9,9 +9,6 @@
  * be used. Those needs to be explicitly defined in this header file. */
 #include_next <net/ip_tunnels.h>
 
-#ifndef TUNNEL_ERSPAN_OPT
-#define TUNNEL_ERSPAN_OPT	__cpu_to_be16(0x4000)
-#endif
 #define ovs_ip_tunnel_encap ip_tunnel_encap
 
 #ifndef HAVE_IP_TUNNEL_INFO_OPTS_SET_FLAGS
@@ -510,6 +507,10 @@ static inline int iptunnel_pull_offloads(struct sk_buff *skb)
 #define skb_is_encapsulated ovs_skb_is_encapsulated
 bool ovs_skb_is_encapsulated(struct sk_buff *skb);
 
+#ifndef TUNNEL_ERSPAN_OPT
+#define TUNNEL_ERSPAN_OPT	__cpu_to_be16(0x4000)
+#endif
+
 #ifndef TUNNEL_GTPU_OPT
 #define TUNNEL_GTPU_OPT          __cpu_to_be16(0x8000)
 #endif
diff --git a/lib/dpif-netlink-rtnl.c b/lib/dpif-netlink-rtnl.c
index 9db6d925f..c9ceb0e0f 100644
--- a/lib/dpif-netlink-rtnl.c
+++ b/lib/dpif-netlink-rtnl.c
@@ -354,7 +354,6 @@ dpif_netlink_rtnl_create(const struct netdev_tunnel_config *tnl_cfg,
     ifinfo = ofpbuf_put_zeros(&request, sizeof(struct ifinfomsg));
     ifinfo->ifi_change = ifinfo->ifi_flags = IFF_UP;
     nl_msg_put_string(&request, IFLA_IFNAME, name);
-    nl_msg_put_u32(&request, IFLA_MTU, MAX_MTU);
     linkinfo_off = nl_msg_start_nested(&request, IFLA_LINKINFO);
     nl_msg_put_string(&request, IFLA_INFO_KIND, kind);
     infodata_off = nl_msg_start_nested(&request, IFLA_INFO_DATA);
@@ -362,6 +361,7 @@ dpif_netlink_rtnl_create(const struct netdev_tunnel_config *tnl_cfg,
     /* tunnel unique info */
     switch (type) {
     case OVS_VPORT_TYPE_VXLAN:
+        nl_msg_put_u32(&request, IFLA_MTU, MAX_MTU);
         nl_msg_put_u8(&request, IFLA_VXLAN_LEARNING, 0);
         nl_msg_put_u8(&request, IFLA_VXLAN_COLLECT_METADATA, 1);
         nl_msg_put_u8(&request, IFLA_VXLAN_UDP_ZERO_CSUM6_RX, 1);
@@ -377,9 +377,11 @@ dpif_netlink_rtnl_create(const struct netdev_tunnel_config *tnl_cfg,
     case OVS_VPORT_TYPE_ERSPAN:
     case OVS_VPORT_TYPE_IP6ERSPAN:
     case OVS_VPORT_TYPE_IP6GRE:
+        nl_msg_put_u32(&request, IFLA_MTU, MAX_MTU);
         nl_msg_put_flag(&request, IFLA_GRE_COLLECT_METADATA);
         break;
     case OVS_VPORT_TYPE_GENEVE:
+        nl_msg_put_u32(&request, IFLA_MTU, MAX_MTU);
         nl_msg_put_flag(&request, IFLA_GENEVE_COLLECT_METADATA);
         nl_msg_put_u8(&request, IFLA_GENEVE_UDP_ZERO_CSUM6_RX, 1);
         nl_msg_put_be16(&request, IFLA_GENEVE_PORT, tnl_cfg->dst_port);
-- 
2.17.1

